#include <windows.h>

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>








typedef struct Win32Timer {
	int64_t perf_freq;
	int64_t last_counter;
} Win32Timer;

typedef struct Backbuffer {
	int width;
	int height;
	int pitch;			// bytes per row
	void* memory;		// BGRA pixels
	BITMAPINFO bmi;		// header for StretchDIBits
} Backbuffer;

enum {
	GRID_W = 30,
	GRID_H = 20,
	CELL_SIZE = 24
};

typedef struct BoardLayout {
	int board_px_w;
	int board_px_h;
	int origin_x;
	int origin_y;
} BoardLayout;

typedef struct IVec2 {
	int x;
	int y;
} IVec2;

enum {
	SNAKE_MAX_SEGMENTS = GRID_W * GRID_H
};

typedef struct SnakeGame {
	IVec2 segments[SNAKE_MAX_SEGMENTS];
	int segment_count;

	IVec2 food;

	// Stored for later checkpoints (movement/input)
	int dir_x;
	int dir_y;
} SnakeGame;







static SnakeGame g_game;
static bool g_running;
static Backbuffer g_backbuffer;
static BoardLayout g_layout;






// Backbuffer
static void backbuffer_free(Backbuffer* b) {
	if (b->memory) {
		VirtualFree(b->memory, 0, MEM_RELEASE);
		b->memory = 0;
	}

	b->width = 0;
	b->height = 0;
	b->pitch = 0;
}

static void backbuffer_resize(Backbuffer* b, int new_w, int new_h) {
	if (new_w <= 0 || new_h <= 0) {
		backbuffer_free(b);
		return;
	}

	if (b->memory && b->width == new_w && b->height == new_h) {
		return;
	}

	backbuffer_free(b);

	b->width = new_w;
	b->height = new_h;

	int bytes_per_pixel = 4;
	b->pitch = b->width * bytes_per_pixel;

	size_t total_bytes = (size_t)b->pitch * (size_t)b->height;

	b->memory = VirtualAlloc(0, total_bytes, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);

	b->bmi.bmiHeader.biSize = sizeof(b->bmi.bmiHeader);
	b->bmi.bmiHeader.biWidth = b->width;
	b->bmi.bmiHeader.biHeight = -b->height;
	b->bmi.bmiHeader.biPlanes = 1;
	b->bmi.bmiHeader.biBitCount = 32;
	b->bmi.bmiHeader.biCompression = BI_RGB;
	b->bmi.bmiHeader.biSizeImage = 0;
}
static void backbuffer_clear(Backbuffer* b, uint32_t color_bgra) {
	if (!b->memory) {
		return;
	}

	// each pixel is 4 bytes bgra in memory when using bi_rgb 32-bit
	uint8_t* row = (uint8_t*)b->memory;

	for (int y = 0; y < b->height; y += 1) {
		uint32_t* pixel = (uint32_t*)row;
		for (int x = 0; x < b->width; x += 1) {
			pixel[x] = color_bgra;
		}

		row += b->pitch;
	}
}

static void backbuffer_present(HDC dc, const Backbuffer* b, int dest_w, int dest_h) {
	if (!b->memory) {
		return;
	}

	StretchDIBits(
		dc,
		0, 0, dest_w, dest_h,     // DEST = actual client size
		0, 0, b->width, b->height,// SRC = backbuffer size
		b->memory,
		&b->bmi,
		DIB_RGB_COLORS,
		SRCCOPY
	);
}










// Timing
static void timer_init(Win32Timer* t) {
	LARGE_INTEGER freq;
	QueryPerformanceFrequency(&freq);
	t->perf_freq = (int64_t)freq.QuadPart;

	LARGE_INTEGER counter;
	QueryPerformanceCounter(&counter);
	t->last_counter = (int64_t)counter.QuadPart;
}

static float timer_tick_seconds(Win32Timer* t) {
	LARGE_INTEGER counter;
	QueryPerformanceCounter(&counter);

	int64_t now = (int64_t)counter.QuadPart;
	int64_t delta = now - t->last_counter;
	t->last_counter = now;

	double seconds = 0.0;
	if (t->perf_freq > 0) {
		seconds = (double)delta / (double)t->perf_freq;
	}

	if (seconds < 0.0) {
		seconds = 0.0;
	}

	if (seconds > 0.05) {
		seconds = 0.05;
	}

	return (float)seconds;
}








static bool pump_messages(void) {
	MSG msg;
	while (PeekMessageA(&msg, 0, 0, 0, PM_REMOVE)) {
		if (msg.message == WM_QUIT) {
			return false;
		}
		TranslateMessage(&msg);
		DispatchMessageA(&msg);
	}
	return true;
}

static LRESULT CALLBACK wnd_proc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
	switch (msg) {
		case WM_CLOSE: {
			g_running = false;
			return 0;
		}

		case WM_DESTROY: {
			g_running = false;
			PostQuitMessage(0);
			return 0;
		}

		default: {
			return DefWindowProcA(hwnd, msg, wParam, lParam);
		} break;
	}
}



// Grid and Rectangle 
static int int_min(int a, int b) {
	if (a < b) {
		return a;
	}
	return b;
}

static int int_max(int a, int b) {
	if (a > b) {
		return a;
	}
	return b;
}

static int clamp_int(int v, int lo, int hi) {
	if (v < lo) {
		return lo;
	}
	if (v > hi) {
		return hi;
	}
	return v;
}

static void board_layout_compute(BoardLayout* out, int client_w, int client_h) {
	int board_w = GRID_W * CELL_SIZE;
	int board_h = GRID_H * CELL_SIZE;

	int ox = (client_w - board_w) / 2;
	int oy = (client_h - board_h) / 2;

	if (ox < 0) {
		ox = 0;
	}

	if (oy < 0) {
		oy = 0;
	}

	out->board_px_w = board_w;
	out->board_px_h = board_h;
	out->origin_x = ox;
	out->origin_y = oy;
}

static void cell_to_pixel_rect(const BoardLayout* l, int cell_x, int cell_y,
							   int* out_x0, int* out_y0, int* out_x1, int* out_y1) {
	int x0 = l->origin_x + cell_x * CELL_SIZE;
	int y0 = l->origin_y + cell_y * CELL_SIZE;

	int x1 = x0 + CELL_SIZE;
	int y1 = y0 + CELL_SIZE;

	*out_x0 = x0;
	*out_y0 = y0;
	*out_x1 = x1;
	*out_y1 = y1;
}

static bool ivec2_equal(IVec2 a, IVec2 b) {
	return (a.x == b.x) && (a.y == b.y);
}

static bool cell_inside_grid(int x, int y) {
	if (x < 0) return false;
	if (y < 0) return false;
	if (x >= GRID_W) return false;
	if (y >= GRID_H) return false;
	return true;
}


static void draw_rect(Backbuffer* b, int x0, int y0, int x1, int y1, uint32_t color_bgra) {
	if (!b->memory) {
		return;
	}

	// Normalize so x0 <= x1, y0 <= y1
	int min_x = int_min(x0, x1);
	int max_x = int_max(x0, x1);
	int min_y = int_min(y0, y1);
	int max_y = int_max(y0, y1);

	// Clip to backbuffer bounds
	min_x = clamp_int(min_x, 0, b->width);
	max_x = clamp_int(max_x, 0, b->width);
	min_y = clamp_int(min_y, 0, b->height);
	max_y = clamp_int(max_y, 0, b->height);

	// Fully clipped away?
	if (min_x >= max_x || min_y >= max_y) {
		return;
	}

	// Draw rows
	uint8_t* base = (uint8_t*)b->memory;
	for (int y = min_y; y < max_y; y += 1) {
		uint32_t* pixel = (uint32_t*)(base + (size_t)y * (size_t)b->pitch);
		for (int x = min_x; x < max_x; x += 1) {
			pixel[x] = color_bgra;
		}
	}
}

static void game_reset(SnakeGame* g) {
	// Start the snake near the center, horizontal, moving right later.
	int start_x = GRID_W / 2;
	int start_y = GRID_H / 2;

	g->segment_count = 4;

	// Head at index 0 (common convention)
	g->segments[0] = (IVec2){ start_x,     start_y };
	g->segments[1] = (IVec2){ start_x - 1, start_y };
	g->segments[2] = (IVec2){ start_x - 2, start_y };
	g->segments[3] = (IVec2){ start_x - 3, start_y };

	g->dir_x = 1;
	g->dir_y = 0;

	// Put food somewhere obvious for now.
	g->food = (IVec2){ 5, 5 };
	for (int i = 0; i < g->segment_count; i += 1) {
		if (ivec2_equal(g->food, g->segments[i])) {
			g->food = (IVec2){ 2, 2 };
			break;
		}
	}
}

static void draw_cell_filled(const BoardLayout* l, int cell_x, int cell_y, uint32_t color_bgra) {
	int x0, y0, x1, y1;
	cell_to_pixel_rect(l, cell_x, cell_y, &x0, &y0, &x1, &y1);

	// Add padding so cells have spacing
	int pad = 2;
	draw_rect(&g_backbuffer, x0 + pad, y0 + pad, x1 - pad, y1 - pad, color_bgra);
}


// Frame Work
static void do_frame_work(HWND hwnd, float dt_seconds) {
	// Always sync buffer to real client size (fixes black strips).
	RECT rc;
	GetClientRect(hwnd, &rc);

	int client_w = rc.right - rc.left;
	int client_h = rc.bottom - rc.top;

	backbuffer_resize(&g_backbuffer, client_w, client_h);

	(void)dt_seconds;

	uint32_t clear_color = 0xFF202040;
	backbuffer_clear(&g_backbuffer, clear_color);

	// Compute board layout based on the current client size
	board_layout_compute(&g_layout, client_w, client_h);

	// Board background
	int board_x0 = g_layout.origin_x;
	int board_y0 = g_layout.origin_y;
	int board_x1 = g_layout.origin_x + g_layout.board_px_w;
	int board_y1 = g_layout.origin_y + g_layout.board_px_h;

	draw_rect(&g_backbuffer, board_x0, board_y0, board_x1, board_y1, 0xFF101018);

	// Board border (4 thin rectangles)
	int border = 3;

	// top
	draw_rect(&g_backbuffer, board_x0 - border, board_y0 - border,
			  board_x1 + border, board_y0, 0xFFFFFFFF);

	// bottom
	draw_rect(&g_backbuffer, board_x0 - border, board_y1,
			  board_x1 + border, board_y1 + border, 0xFFFFFFFF);

	// left
	draw_rect(&g_backbuffer, board_x0 - border, board_y0,
			  board_x0, board_y1, 0xFFFFFFFF);

	// right
	draw_rect(&g_backbuffer, board_x1, board_y0,
			  board_x1 + border, board_y1, 0xFFFFFFFF);

	// Draw food
	draw_cell_filled(&g_layout, g_game.food.x, g_game.food.y, 0xFFFFA000);

	// Draw snake segments
	for (int i = 0; i < g_game.segment_count; i += 1) {
		IVec2 s = g_game.segments[i];

		// Safety: only draw if inside grid
		if (cell_inside_grid(s.x, s.y)) {
			uint32_t color = 0xFF00CC00; // body green
			if (i == 0) {
				color = 0xFF00FF00; // head brighter
			}
			draw_cell_filled(&g_layout, s.x, s.y, color);
		}
	}


	HDC dc = GetDC(hwnd);
	backbuffer_present(dc, &g_backbuffer, client_w, client_h);
	ReleaseDC(hwnd, dc);

	// title update (optional)
	static float title_timer = 0.0f;
	title_timer += dt_seconds;

	if (title_timer >= 0.25f) {
		title_timer = 0.0f;

		float fps = 0.0f;
		if (dt_seconds > 0.0f) {
			fps = 1.0f / dt_seconds;
		}

		char buffer[256];
		snprintf(buffer, sizeof(buffer), "Snake - dt: %.4f  fps: %.1f", dt_seconds, fps);
		SetWindowTextA(hwnd, buffer);
	}
}










int WINAPI WinMain(HINSTANCE instance, HINSTANCE prev_instance, LPSTR cmd_line, int show_code) {
	(void)prev_instance;
	(void)cmd_line;
	(void)show_code;

	WNDCLASSA wc = { 0 };
	wc.style = CS_OWNDC | CS_HREDRAW | CS_VREDRAW;
	wc.lpfnWndProc = wnd_proc;
	wc.hInstance = instance;
	wc.lpszClassName = "MySnakeGameWin32MemAlloc";
	
	RegisterClassA(&wc);

	HWND hwnd = CreateWindowExA(
		0, 
		wc.lpszClassName,
		"My Snake Game Win32 Mem Alloc",
		WS_OVERLAPPEDWINDOW | WS_VISIBLE,
		CW_USEDEFAULT, CW_USEDEFAULT,
		900, 700,
		0, 0, instance, 0
	);

	RECT rc;
	GetClientRect(hwnd, &rc);
	int client_w = rc.right - rc.left;
	int client_h = rc.bottom - rc.top;
	backbuffer_resize(&g_backbuffer, client_w, client_h);

	game_reset(&g_game);

	Win32Timer timer;
	timer_init(&timer);

	g_running = true;
	while (g_running) {
		if (!pump_messages()) {
			g_running = false;
			break;
		}

		float dt_seconds = timer_tick_seconds(&timer);

		do_frame_work(hwnd, dt_seconds);

		Sleep(1);
	}

	backbuffer_free(&g_backbuffer);

	return 0;
}

